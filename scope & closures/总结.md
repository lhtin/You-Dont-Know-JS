# 你不知道的JavaScript：作用域与闭包

**在变量中存储值以及之后的获取或修改该值**的基础范式存在于几乎所有编程语言中。程序拥有状态。

如何实现这个范式，也就是说当程序运行时，**去哪里查找以及如何查找变量**，是需要一套规则，这套规则叫做**作用域**。

作用域根据规则的不同，主要有**词法作用域**（静态作用域）和**动态作用域**两类。

代码在运行过程中需要处在某个作用域下，才能确定所需的**变量的值和存储位置**。词法作用域是根据函数定义时所处的位置确定的，而动态作用域则是根据函数被调用的位置所确定。

作用域会进行嵌套，查找时从变量所处的作用域往外查找，直到最外层作用域（JS中是全局作用域）。除了函数，好包括`with`和`try/catch`也会形成作用域。

定义一个函数会形成一个作用域，函数内声明的变量会属于这个作用域。

ES5中，`if`等语句块中声明的变量不会形成作用域，到了ES6，通过`let`声明的变量只属于该语句块。

变量什么时候会被加到作用域中去：编译时将作用域下的所有声明的变量（包括函数）添加到作用域中去，而不管声明的位置。

函数执行时所处的作用域是定义时所处的外作用域，而不是执行时所处的外作用域。

> 闭包（Closure，Lexical Closure）是指当函数能记住并且访问它所处的作用域即使函数不在该作用域中执行。尤其是函数里面包含了自由变量（即引用了不在函数内部声明的变量）。

为什么会出现闭包：词法作用域、函数是一等公民

其实闭包是词法作用域的一个自然的结果。

闭包的作用：为异步执行的函数提供确定的作用域、模块化。

为什么Java中不强调闭包？因为Java中函数的调用方式是固定的。

带来的问题：闭包所以来的作用域不会被销毁。比如运行一个函数后返回了另外一个函数，那么前一个函数中的变量可能就不能被销毁，因为饭回来的函数中可能用的到。

```js
let closure = (function outer() {
    let out = 5;
    return function inner() {
        console.log(out);
    }
})();

// Closure是一个携带了定义时的作用域环境的函数。
/*
1. closure包含一个inner函数
2. closure包含了inner函数创建时所处的作用域链{out: 5}
*/

```

优化：去闭包。将自由变量当成参数传给函数。

```js
let f = (function outer() {
    let out = 5;
    return {
        args: [out],
        inner: function inner(out) {
            console.log(out);
        }
    }
})();

f();
```


参考：

- https://www.ibm.com/developerworks/cn/linux/l-cn-closure/